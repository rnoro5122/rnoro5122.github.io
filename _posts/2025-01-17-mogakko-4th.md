---
title: 2025 하계 모각코 4주차
date: 2025-01-17 13:50:00 +0900
categories: [2025 동계 모각코]
tags: [2025동계모각코, c]     # TAG names should always be lowercase
---

C언어 학습이 점점 심화되고 있다. 지난주에는 배열, 함수, 파일 입출력, 동적 메모리 할당 같은 개념을 학습했다. 이번주차의 핵심 내용 중 하나인 
포인터는 C언어의 가장 강력한 도구 중 하나로, 메모리와 데이터를 효율적으로 관리하는 데 필수적이다. 이번 글에서는 포인터와 동적 메모리 할당의 개념적인 부분을 
중점적으로 살펴보고, 구조체에 대해서도 추가적으로 다뤄보고자 한다.

---

## 1. 포인터란 무엇인가?

포인터는 C언어에서 매우 중요한 개념으로, **메모리 주소를 저장하는 변수**이다. 일반적인 변수는 데이터를 직접 저장하지만, 포인터는 데이터가 저장된 **메모리 주소**를 저장한다. 이로 인해 포인터를 사용하면 데이터를 간접적으로 조작하거나 메모리를 효율적으로 관리할 수 있다.

### 포인터의 주요 개념
1. **메모리 주소**:  
   컴퓨터에서 모든 데이터는 메모리에 저장되며, 각 데이터는 고유한 메모리 주소를 가진다. 포인터는 이 메모리 주소를 저장하는 역할을 한다.

2. **간접 접근**:  
   포인터를 통해 변수나 데이터에 간접적으로 접근할 수 있다. 즉, 포인터가 가리키는 주소를 통해 해당 주소에 저장된 값을 읽거나 수정할 수 있다.

3. **포인터의 유연성**:
  - 배열과 함께 사용하여 데이터를 효율적으로 처리할 수 있다.
  - 함수 인자로 사용되어 데이터를 복사하지 않고 참조를 통해 전달할 수 있다.
  - 동적 메모리 할당과 결합하여 실행 중에 유연하게 메모리를 관리할 수 있다.

### 포인터 선언과 사용
포인터는 다음과 같이 선언하고 사용할 수 있다:
```c
#include <stdio.h>

int main() {
    int num = 10;        // 정수형 변수 선언
    int* ptr = &num;     // num의 주소를 저장하는 포인터 선언

    printf("num의 값: %d\n", num);          // 변수의 값 출력
    printf("num의 주소: %p\n", &num);       // 변수의 주소 출력
    printf("ptr이 가리키는 값: %d\n", *ptr); // 포인터를 통한 간접 참조 값 출력

    *ptr = 20;           // 포인터를 통해 num의 값을 변경
    printf("num의 새로운 값: %d\n", num);   // 변경된 값 출력

    return 0;
}
```

실행결과:
```text
num의 값: 10
num의 주소: 0x7ffee2b8c4ec (주소는 시스템마다 다름)
ptr이 가리키는 값: 10
num의 새로운 값: 20
```

### 포인터의 활용 사례
- **배열과 문자열 처리**:  
  배열 이름은 첫 번째 요소의 주소를 나타내므로, 배열을 포인터처럼 사용할 수 있다.
- **함수 호출 시 참조 전달**:  
  함수에 값을 복사하지 않고 변수의 주소를 전달하여 직접 값을 변경할 수 있다.
- **동적 메모리 관리**:  
  실행 중 필요한 만큼 메모리를 할당하고 해제하는 데 사용된다.

---

## 2. 메모리와 C언어

C언어에서 프로그램이 실행될 때 사용하는 메모리는 크게 다음 네 가지 영역으로 나뉜다:

### 1) 코드 영역 (Code Segment)
- 프로그램의 실행 코드가 저장되는 영역이다.
- 컴파일 시 고정되며 실행 중 변경되지 않는다.

### 2) 데이터 영역 (Data Segment)
- 전역 변수와 정적 변수가 저장되는 공간이다.
- 프로그램이 시작될 때 할당되고 종료될 때 해제된다.
- 초기화된 데이터와 초기화되지 않은 데이터로 나뉜다.

### 3) 스택 영역 (Stack Segment)
- 함수 호출 시 생성되는 지역 변수와 매개변수가 저장되는 공간이다.
- 함수가 종료되면 해당 스택 프레임이 자동으로 해제된다.
- 스택은 LIFO(Last In First Out) 방식으로 동작한다.

### 4) 힙 영역 (Heap Segment)
- 동적 메모리가 할당되는 공간이다.
- 프로그래머가 직접 `malloc`이나 `calloc` 같은 함수를 통해 메모리를 요청하고, 사용 후 `free`로 해제해야 한다.
- 힙은 스택과 달리 크기가 고정되지 않고 실행 중 유연하게 확장 및 축소된다.

---

## 3. 동적 메모리 할당의 개념

동적 메모리 할당은 프로그램 실행 중 필요한 만큼의 메모리를 힙(Heap) 영역에서 요청하고 사용하는 방법이다. 이는 정적 메모리 할당(컴파일 시 크기 고정)과 
대비되는 개념으로, 프로그램의 유연성을 크게 향상시킨다.

### 동적 메모리 할당이 필요한 이유
1. **유연한 메모리 관리**:
  - 배열처럼 고정된 크기의 자료구조 대신, 실행 중 필요한 만큼만 메모리를 할당할 수 있다.
  - 예를 들어 사용자 입력에 따라 크기가 달라지는 데이터를 처리할 때 유용하다.

2. **효율적인 자원 활용**:
  - 시스템 자원을 효율적으로 활용하며, 필요하지 않은 경우 메모리를 해제하여 낭비를 줄일 수 있다.

3. **복잡한 자료구조 구현**:
  - 연결 리스트, 트리, 그래프 같은 자료구조는 동적 메모리를 통해 구현된다.

### 정적 메모리 할당 VS 동적 메모리 할당

C언어에서 메모리를 사용하는 방식은 크게 **정적 메모리 할당**과 **동적 메모리 할당**으로 나뉜다. 두 방식은 각각의 장단점과 특징이 있으며, 적절한 상황에 
따라 선택적으로 사용된다.

#### **1. 정적 메모리 할당 (Static Memory Allocation)**

정적 메모리 할당은 **컴파일 시점**에 변수나 배열의 크기를 결정하고, 프로그램 실행 중에는 변경할 수 없는 방식이다.

- **특징**:
  - **고정된 크기**: 변수나 배열의 크기가 컴파일 시점에 결정되며, 실행 중에는 변경할 수 없다.
  - **자동 해제**: 함수가 종료되거나 변수의 유효 범위를 벗어나면 메모리가 자동으로 해제된다.
  - **스택(Stack) 영역 사용**: 정적 메모리는 주로 스택 영역에서 관리된다.
  - **빠른 속도**: 메모리 할당 및 해제 속도가 빠르다.

- **장점**:
  - 코드가 단순하며, 프로그래머가 직접 메모리를 관리할 필요가 없다.
  - 실행 속도가 빠르고 안정적이다.

- **단점**:
  - 데이터 크기가 실행 중에 변할 수 있는 경우 유연성이 부족하다.
  - 필요 이상으로 큰 크기를 미리 할당하면 메모리가 낭비될 수 있다.

- **예시 코드**:
```c
int arr; // 정적 배열 선언
```

#### **2. 동적 메모리 할당 (Dynamic Memory Allocation)**

동적 메모리 할당은 **프로그램 실행 중(런타임)** 필요한 만큼의 메모리를 힙(Heap) 영역에서 요청하여 사용하는 방식이다.

- **특징**:
  - **유연한 크기 조정**: 프로그램 실행 중 필요한 만큼만 메모리를 할당할 수 있다.
  - **수동 해제 필요**: 프로그래머가 명시적으로 `free` 함수를 호출하여 메모리를 해제해야 한다.
  - **힙(Heap) 영역 사용**: 동적 메모리는 힙 영역에서 관리된다.
  - **유연성 제공**: 데이터 크기가 가변적인 경우 적합하다.

- **장점**:
  - 실행 중 데이터 크기를 유연하게 조정할 수 있다.
  - 사용자 입력이나 런타임 조건에 따라 필요한 만큼만 메모리를 사용할 수 있다.

- **단점**:
  - 프로그래머가 직접 관리해야 하므로 실수로 인해 **메모리 누수(Memory Leak)**가 발생할 수 있다.
  - 스택보다 접근 속도가 느리고, 관리가 복잡하다.

- **예시 코드**:
  int *arr = (int *)malloc(10 * sizeof(int)); // 동적 배열 선언
  free(arr); // 사용 후 메모리 해제
  text

---

### 정적 할당과 동적 할당의 차이 비교 표

| 특징                | 정적 메모리 할당                           | 동적 메모리 할당                           |
|---------------------|-------------------------------------------|-------------------------------------------|
| **메모리 결정 시점** | 컴파일 시점                                | 실행 시점                                  |
| **메모리 위치**      | 스택(Stack)                                | 힙(Heap)                                   |
| **크기 변경 가능 여부** | 불가능                                     | 가능                                      |
| **메모리 해제 방식** | 함수 종료 또는 범위 벗어날 때 자동 해제       | 프로그래머가 명시적으로 `free` 호출 필요    |
| **속도**             | 빠름                                      | 상대적으로 느림                            |
| **유연성**           | 낮음                                      | 높음                                      |
| **사용 예시**        | 고정 크기의 배열                          | 가변 크기의 데이터 처리 (예: 연결 리스트) |

---

### 동적 메모리 할당과 해제
동적 메모리는 프로그래머가 직접 관리해야 하며, 이를 소홀히 하면 다음과 같은 문제가 발생할 수 있다:
- **메모리 누수 (Memory Leak)**:  
  할당한 메모리를 해제하지 않으면 사용하지 않는 공간이 계속 차지되어 시스템 성능 저하를 초래한다.
- **잘못된 접근 (Dangling Pointer)**:  
  이미 해제된 메모리에 접근하려고 하면 예측 불가능한 오류가 발생한다.

---

## 4. 구조체란 무엇인가?

구조체(Struct)는 서로 다른 자료형을 하나로 묶어주는 사용자 정의 데이터 타입이다. 여러 변수를 하나로 묶어 관리할 수 있어 복잡한 데이터를 효율적으로 처리할 수 있다.

### 구조체의 주요 특징
1. **데이터 그룹화**:
  - 서로 관련 있는 데이터를 하나의 단위로 묶어 관리한다.
  - 예를 들어 학생 정보를 나타낼 때 이름, 나이, 학번 등을 하나의 구조체로 묶을 수 있다.

2. **유연성 제공**:
  - 배열과 달리 서로 다른 자료형을 포함할 수 있어 복잡한 데이터를 표현하기 용이하다.

3. **메모리 효율성**:
  - 구조체는 연속된 메모리에 저장되므로 접근 속도가 빠르다.

### 구조체 선언과 사용
구조체는 다음과 같이 선언하고 사용할 수 있다:
```c
struct Student {
  char name;
  int age;
  int student_id;
};

int main() {
  struct Student s1;
  s1.name = "Alice";
  s1.age = 20;
  s1.student_id = 20250001;

  printf("Name: %s, Age: %d, ID: %d\n", s1.name, s1.age, s1.student_id); // 출력: Name: Alice, Age: 20, ID: 20250001
  return 0;
}
```

### 구조체와 포인터
구조체는 포인터와 함께 사용하면 더욱 강력하다. 특히 동적 메모리를 사용해 구조체 배열을 생성하거나 연결 리스트 같은 자료구조를 구현할 때 유용하다.

---

## 마무리

이번 주차에는 C언어에서 가장 중요한 개념인 포인터와 동적 메모리 할당에 대해 심도 있게 다뤄보았으며, 추가적으로 구조체라는 강력한 데이터 타입에 대해서도 학습했다. 구조체는 복잡한 데이터를 체계적으로 관리하는 데 매우 유용하며, 특히 포인터와 결합하면 더욱 강력해진다. 다음 주에는 연결 리스트와 같은 자료구조를 중심으로 학습하며 C언어 학습을 이어나갈 계획이다.

